# 动态规划

## 什么是动态规划

我们把问题分解成多个阶段，每个阶段对应一个决策。我们记录每一个阶段可达的状态集合（去掉重复的），然后通过当前阶段的状态集合，来推导下一个阶段的状态集合，动态的向前推进。

## 例题1：01背包问题

问题：假设背包的最大承载量是9，我们有5个不同的物品，每个物品的重量分别是2，2，4，6，3，在不超过背包能够承载重量的前提下，如何让背包中物品的总重量最大？

解析：将整个分解过程分为n个阶段，每个阶段都会判断是否将一个物品放入背包中。每个阶段判断结束后，更新背包的状态，定义一个数组states[n][w+1]来表示其状态，每次决策都有两个决定：放还是不放，那么程序就很好写了。
```java
package Test;

public class KnapSack {
	//weight: 物品重量，n: 物品个数，w: 背包可承载重量
	public int knapsack(int[] weight, int n, int w) {
	  boolean[][] states = new boolean[n][w+1]; // 默认值 false
	  states[0][0] = true;  // 第一行的数据要特殊处理，可以利用哨兵优化
	  states[0][weight[0]] = true;
	  for (int i = 1; i < n; ++i) { // 动态规划状态转移
	    for (int j = 0; j <= w; ++j) {// 不把第 i 个物品放入背包
	      if (states[i-1][j] == true) states[i][j] = states[i-1][j];
	    }
	    for (int j = 0; j <= w-weight[i]; ++j) {// 把第 i 个物品放入背包
	      if (states[i-1][j]==true) states[i][j+weight[i]] = true;
	    }
	  }
	  for (int i = w; i >= 0; --i) { // 输出结果,从最后一排开始找一个值为true的最接近w的值
	    if (states[n-1][i] == true) return i;
	  }
	  return 0;
	}
	
	public static void main(String[] args) {
		KnapSack knap = new KnapSack();
		int[] testArr = {2,2,4,6,3};
		System.out.println(knap.knapsack(testArr,5,9));
	}

}
```
结果为9

时间复杂度为O(n * w),其中n代表物品个数，w代表背包能够承载的总重量。空间复杂度较高，需要额外申请一个n * w+1 的二维数组。





